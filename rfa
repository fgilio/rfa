#!/bin/bash
set -e

SCRIPT="$(readlink -f "$0" 2>/dev/null || realpath "$0")"
APP_DIR="$(cd "$(dirname "$SCRIPT")/src" && pwd)"
PID_FILE="$APP_DIR/storage/rfa.pid"
PORT_FILE="$APP_DIR/storage/rfa.port"
LOCK_FILE="$APP_DIR/storage/rfa.lock"

# -- Subcommands --

cmd_stop() {
    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            if [ ! -f "$PORT_FILE" ]; then
                echo "Warning: no port file - cannot verify PID $PID belongs to this instance (stale PID file)"
            else
                EXPECTED_PORT=$(cat "$PORT_FILE")
                PROC_ARGS=$(ps -p "$PID" -o args= 2>/dev/null || true)
                if echo "$PROC_ARGS" | grep -qF "$APP_DIR/artisan" && \
                   echo "$PROC_ARGS" | grep -qF -- "--port=$EXPECTED_PORT"; then
                    kill "$PID" 2>/dev/null
                    echo "Stopped rfa daemon (PID $PID)"
                else
                    echo "Warning: PID $PID is not this rfa instance (stale PID file)"
                fi
            fi
        else
            echo "Stale PID file (process $PID not running)"
        fi
    else
        echo "No rfa daemon running"
    fi
    rm -f "$PID_FILE" "$PORT_FILE"
    rm -rf "$LOCK_FILE"
}

cmd_status() {
    if [ -f "$PID_FILE" ] && [ -f "$PORT_FILE" ]; then
        PID=$(cat "$PID_FILE")
        PORT=$(cat "$PORT_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            echo "rfa daemon running (PID $PID) at http://127.0.0.1:$PORT"
            echo ""
            php "$APP_DIR/artisan" tinker --execute="
                \$projects = \App\Models\Project::orderBy('name')->get();
                if (\$projects->isEmpty()) { echo 'No projects registered'; return; }
                foreach (\$projects as \$p) {
                    echo \$p->name . ' (' . \$p->branch . ') -> /p/' . \$p->slug . PHP_EOL;
                }
            " 2>/dev/null
            return 0
        fi
    fi
    echo "No rfa daemon running"
    return 1
}

is_daemon_alive() {
    [ -f "$PID_FILE" ] || return 1
    PID=$(cat "$PID_FILE")
    kill -0 "$PID" 2>/dev/null || return 1

    # Verify it's actually an artisan serve process
    ps -p "$PID" -o args= 2>/dev/null | grep -q "artisan serve" || return 1

    # Verify port responds
    [ -f "$PORT_FILE" ] || return 1
    PORT=$(cat "$PORT_FILE")
    curl -s -o /dev/null --max-time 2 "http://127.0.0.1:$PORT" 2>/dev/null || return 1

    return 0
}

start_daemon() {
    # Acquire lock via mkdir (atomic on all POSIX systems including macOS)
    if ! mkdir "$LOCK_FILE" 2>/dev/null; then
        # Another instance is starting - wait briefly and check again
        sleep 1
        if is_daemon_alive; then
            return 0
        fi
        # Stale lock - remove and retry once
        rm -rf "$LOCK_FILE"
        if ! mkdir "$LOCK_FILE" 2>/dev/null; then
            echo "Error: could not acquire lock" >&2
            exit 1
        fi
    fi

    # Double-check after acquiring lock
    if is_daemon_alive; then
        rm -rf "$LOCK_FILE"
        return 0
    fi

    # Clean stale files
    rm -f "$PID_FILE" "$PORT_FILE"

    # Find free port starting at 4000
    PORT=4000
    while lsof -i :"$PORT" >/dev/null 2>&1; do PORT=$((PORT + 1)); done

    # Run migrations
    php "$APP_DIR/artisan" migrate --force --quiet 2>/dev/null || true

    # Start server with nohup (survives terminal close)
    nohup php "$APP_DIR/artisan" serve --host=127.0.0.1 --port="$PORT" >/dev/null 2>&1 &
    SERVER_PID=$!

    echo "$SERVER_PID" > "$PID_FILE"
    echo "$PORT" > "$PORT_FILE"

    # Release lock
    rm -rf "$LOCK_FILE"

    # Wait for server readiness
    for i in $(seq 1 50); do
        if curl -s -o /dev/null --max-time 1 "http://127.0.0.1:$PORT" 2>/dev/null; then
            echo "rfa daemon started (PID $SERVER_PID) at http://127.0.0.1:$PORT"
            return 0
        fi
        sleep 0.2
    done

    echo "Error: server failed to start" >&2
    kill "$SERVER_PID" 2>/dev/null
    rm -f "$PID_FILE" "$PORT_FILE"
    exit 1
}

cmd_dump() {
    DB="$APP_DIR/database/database.sqlite"
    if [ ! -f "$DB" ]; then
        echo "No database found"
        return
    fi
    DUMP_DIR="$APP_DIR/storage/dumps/$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$DUMP_DIR"
    sqlite3 "$DB" \
        ".headers on" ".mode csv" ".output $DUMP_DIR/projects.csv" "SELECT * FROM projects;" \
        ".output $DUMP_DIR/review_sessions.csv" "SELECT * FROM review_sessions;"
    echo "Dumped to $DUMP_DIR"
}

cmd_flush() {
    DB="$APP_DIR/database/database.sqlite"
    if [ ! -f "$DB" ]; then
        echo "No database found"
        return
    fi
    PROJECTS=$(sqlite3 "$DB" "SELECT COUNT(*) FROM projects;")
    SESSIONS=$(sqlite3 "$DB" "SELECT COUNT(*) FROM review_sessions;")
    sqlite3 "$DB" "DELETE FROM review_sessions; DELETE FROM projects;"
    echo "Flushed $PROJECTS projects and $SESSIONS sessions"
}

open_browser() {
    local URL="$1"
    if command -v open >/dev/null 2>&1; then
        open "$URL"
    elif command -v xdg-open >/dev/null 2>&1; then
        xdg-open "$URL"
    else
        echo "Open in browser: $URL"
    fi
}

# -- Main --

case "${1:-}" in
    stop)   cmd_stop;  exit 0 ;;
    status) cmd_status; exit $? ;;
    dump)   cmd_dump;  exit 0 ;;
    flush)  cmd_flush; exit 0 ;;
esac

# Default: register + open
RFA_REPO_PATH="$(pwd)"

# Validate git repo
git -C "$RFA_REPO_PATH" rev-parse --show-toplevel >/dev/null 2>&1 || {
    echo "Error: not a git repository" >&2
    exit 1
}

# Ensure storage directory exists
mkdir -p "$APP_DIR/storage"

# Start daemon if not running
if ! is_daemon_alive; then
    start_daemon
fi

PORT=$(cat "$PORT_FILE")

# Register project
SLUG=$(php "$APP_DIR/artisan" rfa:register "$RFA_REPO_PATH" 2>/dev/null)
if [ -z "$SLUG" ]; then
    echo "Error: failed to register project" >&2
    exit 1
fi

# Open browser
URL="http://127.0.0.1:$PORT/p/$SLUG"
echo "$URL"
open_browser "$URL"
